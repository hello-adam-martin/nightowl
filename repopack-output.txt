================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-21T04:26:51.128Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Files
================================================================

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}

================
File: HOWITWORKS.md
================
# How NightOwl Works

NightOwl is a Next.js-based web application for a late-night delivery service. This document explains the key components and functionality of the application.

## Project Structure

The project follows a typical Next.js structure:

- `app/`: Contains the main application pages and layouts
- `components/`: Houses reusable React components
- `context/`: Stores React context providers for state management
- `lib/`: Contains utility functions and helpers
- `public/`: Holds static assets
- `types/`: Defines TypeScript type definitions

## Key Components

### 1. HomePage Component

The HomePage component (`components/home-page.tsx`) is the main entry point of the application. It handles:

- Displaying the product catalog
- Managing the shopping cart
- Handling address input and validation
- Implementing the search and category filtering functionality

### 2. Cart Component

The Cart component (`components/Cart.tsx`) manages the shopping cart functionality, including:

- Displaying cart items
- Updating item quantities
- Removing items from the cart
- Handling the checkout process

### 3. AddressForm Component

The AddressForm component handles user address input and validation. It works in conjunction with the AddressContext to manage address-related state across the application.

### 4. ProductGrid Component

The ProductGrid component displays the list of available products, allowing users to add items to their cart.

## State Management

The application uses React Context for state management:

1. CartContext (`context/CartContext.tsx`): Manages the shopping cart state.
2. AddressContext (`context/AddressContext.tsx`): Handles address-related state.

## API Integration

The application interacts with a backend API for various functionalities:

1. Fetching products:
2. Creating payment intents for Stripe integration:

## Styling

The application uses Tailwind CSS for styling, with custom configurations defined in `tailwind.config.ts`. Custom UI components are built using shadcn/ui, a collection of re-usable components built with Radix UI and Tailwind CSS.

## Configuration

The `config/config.ts` file contains various configuration settings for the application, including:

- Store hours
- Service area information
- Product categories
- Site information

## Deployment

The application is designed to be deployed on platforms like Vercel, which offer seamless integration with Next.js applications.

## Summary

NightOwl leverages Next.js, React, and various modern web technologies to create a responsive and user-friendly late-night delivery service application. The modular structure and use of React contexts for state management allow for easy maintenance and scalability.

================
File: README.md
================
# NightOwl

NightOwl is a Next.js-based web application for a late-night delivery service. It allows users to browse products, add items to their cart, and place orders for delivery within a specified service area.

## Features

- Product browsing with category filtering
- Cart management
- Address verification and serviceability check
- Secure payment processing with Stripe
- Responsive design for mobile and desktop

## Technologies Used

- [Next.js](https://nextjs.org/) - React framework for server-side rendering and static site generation
- [TypeScript](https://www.typescriptlang.org/) - Typed superset of JavaScript
- [Tailwind CSS](https://tailwindcss.com/) - Utility-first CSS framework
- [Stripe](https://stripe.com/) - Payment processing
- Custom UI components (based on shadcn/ui)

## Getting Started

1. Clone the repository:
   ```
   git clone https://github.com/your-username/nightowl.git
   cd nightowl
   ```

2. Install dependencies:
   ```
   npm install
   ```

3. Set up environment variables:
   Create a `.env.local` file in the root directory and add the following variables:
   ```
   NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your_stripe_publishable_key
   STRIPE_SECRET_KEY=your_stripe_secret_key
   ```

4. Run the development server:
   ```
   npm run dev
   ```

5. Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Project Structure

- `app/`: Next.js app directory containing pages and layouts
- `components/`: Reusable React components
- `context/`: React context providers for state management
- `lib/`: Utility functions and helpers
- `public/`: Static assets
- `types/`: TypeScript type definitions

## Deployment

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out the [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the [MIT License](LICENSE).

================
File: TODO.md
================
- make sure we get categories from supabase
- create a footer
- expand upon about page
- think about how we can support different areas
    - delivery zones / prices
    - products associated with zones
- email receipts
- integrate real address validation and checking if servicible


make sure product images are all the same size.. at the moment they are changing dependent on whether low stock / no stock message shows or not.

ENHANCEMENTS
- Integrate analytics
- Track top up amounts
- move checkServicibility from home-page to be self contained in the addressForm ??


SAAS
1. set commission
2. set delivery zones for operator

================
File: app/ClientProviders.tsx
================
'use client'

import { CartProvider } from '../context/CartContext';
import { AddressProvider } from '../context/AddressContext';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export default function ClientProviders({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <AddressProvider>
        <CartProvider>
          {children}
        </CartProvider>
      </AddressProvider>
    </QueryClientProvider>
  );
}

================
File: app/about/page.tsx
================
'use client';

import { useState, useEffect } from 'react'
import TopBar from '@/components/TopBar'
import Image from 'next/image'
import { storeConfig } from '@/config/config'
import Cart from '@/components/Cart'
import { useCart } from '@/context/CartContext'
import { siteInfo } from '@/config/config';

const formatHour = (time: string) => {
  const [hours, minutes] = time.split(':').map(Number);
  const period = hours >= 12 ? 'PM' : 'AM';
  const displayHour = hours % 12 || 12;
  return `${displayHour}:${minutes.toString().padStart(2, '0')} ${period}`;
};

export default function AboutPage() {
  const [isCartOpen, setIsCartOpen] = useState(false)
  const [currentDay, setCurrentDay] = useState('');
  const [isStoreOpen, setIsStoreOpen] = useState(false)

  useEffect(() => {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    setCurrentDay(days[new Date().getDay()]);
  }, []);

  useEffect(() => {
    const checkStoreStatus = () => {
      const now = new Date()
      const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase() as keyof typeof storeConfig.hours
      const currentHour = now.getHours()
      const currentMinute = now.getMinutes()
      const { open, close } = storeConfig.hours[currentDay]
      
      const [openHour, openMinute] = open.split(':').map(Number)
      const [closeHour, closeMinute] = close.split(':').map(Number)
      
      const isOpen = (openHour < closeHour || (openHour === closeHour && openMinute < closeMinute)) 
        ? (currentHour > openHour || (currentHour === openHour && currentMinute >= openMinute)) &&
          (currentHour < closeHour || (currentHour === closeHour && currentMinute < closeMinute))
        : (currentHour > openHour || (currentHour === openHour && currentMinute >= openMinute)) ||
          (currentHour < closeHour || (currentHour === closeHour && currentMinute < closeMinute))
      
      setIsStoreOpen(isOpen)
    }

    checkStoreStatus() // Check immediately on mount
    const timer = setInterval(checkStoreStatus, 60000) // Update every minute

    return () => clearInterval(timer)
  }, []);

  const { cart, updateQuantity, removeFromCart } = useCart()

  const getTotalPrice = () => {
    return cart.reduce((total, item) => total + item.price * item.quantity, 0)
  }

  return (
    <div className="min-h-screen bg-gray-100">
      <TopBar 
        currentPage="about" 
        isCartOpen={isCartOpen} 
        setIsCartOpen={setIsCartOpen}
      />

      {/* Main content */}
      <div className="pt-20 p-8">
        <div className="max-w-7xl mx-auto bg-white rounded-lg shadow-lg p-8">
          <div className="flex justify-center mb-6">
            <Image src="/NightOwl.png" alt="NightOwl Logo" width={120} height={120} />
          </div>
          
          <h2 className="text-2xl font-bold text-center mb-6">About NightOwl</h2>
          
          <div className="flex flex-col md:flex-row gap-8">
            {/* Left column: Main content */}
            <div className="md:w-2/3 md:border-r md:pr-8">
              <section className="mb-8">
                <h3 className="text-xl font-semibold mb-4">Our Story</h3>
                <p className="text-gray-700">
                NightOwl was founded with a simple mission: to provide convenient service to our community. We understand that life doesn’t stop at certain hours, and neither should your access to essential items.
                </p>
              </section>

              <section className="mb-8">
                <h3 className="text-xl font-semibold mb-4">What We Offer</h3>
                <p className="text-gray-700">
                  We specialize in delivering a wide range of products, from snacks and beverages to household essentials, right to your doorstep during the late hours when most stores are closed.
                </p>
              </section>

              <section className="mb-8">
                <h3 className="text-xl font-semibold mb-4">Our Commitment</h3>
                <p className="text-gray-700">
                  At NightOwl, we&apos;re committed to providing fast, reliable service with a focus on customer satisfaction. Our team works tirelessly to ensure that your late-night needs are met with efficiency and care.
                </p>
              </section>

              <section className="mb-8">
                <h3 className="text-xl font-semibold mb-4">Our Service Area</h3>
                <p className="text-gray-700">
                  We currently serve Akaroa Township. You can enter your address on the home page to check if we can deliver to you.
                </p>
              </section>

              <section>
                <h3 className="text-xl font-semibold mb-4">Frequently Asked Questions</h3>
                <div className="space-y-4">
                  <div>
                    <h4 className="font-medium">Q: How fast is your delivery?</h4>
                    <p className="text-gray-700">We aim to deliver within 30-45 minutes of order placement, depending on your location.</p>
                  </div>
                  <div>
                    <h4 className="font-medium">Q: Do you have a minimum order amount?</h4>
                    <p className="text-gray-700">Yes, our minimum order amount is ${storeConfig.serviceInfo.minOrderValue.toFixed(2)}.</p>
                  </div>
                  <div>
                    <h4 className="font-medium">Q: What payment methods do you accept?</h4>
                    <p className="text-gray-700">We accept all major credit cards, debit cards, and mobile payment options.</p>
                  </div>
                </div>
              </section>
            </div>

            {/* Right column: Contact info and opening hours */}
            <div className="md:w-1/3 md:pl-8">
              <section className="mb-8">
                <h3 className="text-xl font-semibold mb-4">Contact Us</h3>
                <p className="text-gray-700">
                  Email: {siteInfo.supportEmail}<br />
                  Phone: {siteInfo.supportPhone}
                </p>
              </section>

              <section>
                <h3 className="text-xl font-semibold mb-4">Operating Hours</h3>
                <div className="space-y-1 text-sm text-gray-700">
                  {Object.entries(storeConfig.hours).map(([day, hours]) => (
                    <div key={day} className={`flex ${day === currentDay ? 'font-bold text-blue-600' : ''}`}>
                      <span className="w-24">{day.charAt(0).toUpperCase() + day.slice(1)}:</span>
                      <span>{formatHour(hours.open)} - {formatHour(hours.close)}</span>
                    </div>
                  ))}
                </div>
              </section>
            </div>
          </div>
        </div>
      </div>

      <Cart
        isCartOpen={isCartOpen}
        setIsCartOpen={setIsCartOpen}
        isStoreOpen={isStoreOpen}
        cart={cart}
        isAddressValid={true} 
        updateQuantity={(id, increment) => updateQuantity(id, (cart.find(item => item.id === id)?.quantity ?? 0) + (increment ? 1 : -1))}
        removeFromCart={removeFromCart}
        getTotalPrice={getTotalPrice}
        deliveryCharge={storeConfig.serviceInfo.deliveryCharge}
      />
    </div>
  )
}

================
File: app/api/create-payment-intent/route.ts
================
import { createClient } from '@supabase/supabase-js'
import Stripe from 'stripe'
import { NextResponse } from 'next/server'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-06-20', // Use the latest available API version
})

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function POST(req: Request) {
  const { amount, customerInfo, cartItems } = await req.json()

  try {
    // Check inventory first
    const { data: inventoryCheck, error: inventoryError } = await supabase.rpc('check_inventory', {
      p_cart_items: cartItems
    })

    if (inventoryError) {
      throw inventoryError
    }

    if (!inventoryCheck.success) {
      return NextResponse.json({ 
        error: 'Inventory changes detected',
        message: 'Some items in your cart have limited availability. We\'ve adjusted your cart accordingly. Please review before proceeding.',
        outOfStockItems: inventoryCheck.outOfStockItems 
      }, { status: 400 })
    }

    // Create Stripe PaymentIntent
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: 'nzd',
    })

    // Create order and update inventory
    const { data: orderData, error: orderError } = await supabase.rpc('create_order_and_items', {
      p_customer_name: customerInfo.name,
      p_phone: customerInfo.phone,
      p_address: customerInfo.address,
      p_total: amount / 100, // Convert cents to dollars
      p_delivery_charge: 10, // Assuming fixed delivery charge
      p_status: 'pending',
      p_stripe_payment_intent_id: paymentIntent.id,
      p_cart_items: cartItems
    })

    if (orderError) {
      throw orderError
    }

    return NextResponse.json({ 
      clientSecret: paymentIntent.client_secret,
      orderId: orderData.order_id
    })
  } catch (error) {
    console.error('Error creating order:', error)
    return NextResponse.json({ error: 'An error occurred while processing your order' }, { status: 500 })
  }
}

================
File: app/api/products/route.ts
================
import { createClient } from '@supabase/supabase-js'
import { NextResponse } from 'next/server'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

export async function GET() {
  try {
    const { data, error } = await supabase
      .from('products')
      .select('*')
      .order('id')

    if (error) throw error

    return NextResponse.json(data)
  } catch (error) {
    console.error('Error fetching products:', error)
    return NextResponse.json({ error: 'An error occurred while fetching products' }, { status: 500 })
  }
}

================
File: app/api/send-slack-notification/route.ts
================
import { NextResponse } from 'next/server'
import { WebClient } from '@slack/web-api'

const slackToken = process.env.SLACK_BOT_TOKEN
const slackChannel = process.env.SLACK_CHANNEL_ID

const slack = new WebClient(slackToken)

export async function POST(request: Request) {
  const { orderId, customer, phone, address, items, total, deliveryCharge, specialInstructions } = await request.json()

  const formattedItems = items.map((item: { name: string; quantity: number; price: number }, index: number) => 
    `${index + 1}. ${item.name} x${item.quantity} ($${(item.price * item.quantity).toFixed(2)})`
  ).join('\n')

  const grandTotal = total + deliveryCharge

  const message = {
    text: `New Order #${orderId}`,
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:new: *New Order #${orderId}*\n-----------------------`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:bust_in_silhouette: Customer: ${customer}\n:phone: Phone: ${phone}\n:round_pushpin: Address: ${address}\n-----------------------`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Order Details:*\n${formattedItems}\n-----------------------`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:moneybag: Total: $${total.toFixed(2)}\n:truck: Delivery Charge: $${deliveryCharge.toFixed(2)}\n:money_with_wings: Grand Total: $${grandTotal.toFixed(2)}\n-----------------------`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:spiral_note_pad: Special Instructions: ${specialInstructions || 'None'}`
        }
      }
    ]
  }

  try {
    // Check if the channel exists and the bot is a member
    const channelInfo = await slack.conversations.info({
      channel: slackChannel!
    })

    if (!channelInfo.channel?.is_member) {
      throw new Error('Bot is not a member of this channel')
    }

    await slack.chat.postMessage({
      channel: slackChannel!,
      ...message
    })

    return NextResponse.json({ message: 'Slack notification sent successfully' }, { status: 200 })
  } catch (error) {
    console.error('Error sending Slack notification:', error)
    return NextResponse.json({ message: 'Failed to send Slack notification' }, { status: 500 })
  }
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import ClientProviders from './ClientProviders'
import Footer from '@/components/Footer'

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata: Metadata = {
  title: "NightOwl - Late Night Delivery Service",
  description: "Your go-to late-night delivery service for groceries, household essentials, and more.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <ClientProviders>
          <div className="flex flex-col min-h-screen">
            <main className="flex-grow">
              {children}
            </main>
            <Footer />
          </div>
        </ClientProviders>
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import { HomePage } from "@/components/home-page"

export default function Page() {
  return <HomePage />
}

================
File: components/AddressForm.tsx
================
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Check, X } from 'lucide-react'
import { useAddress } from '../context/AddressContext';
import { useState, useEffect } from 'react';

type ServiceInfo = {
  deliveryTime: string;
  serviceArea: string;
  minOrderValue: number;
}

type AddressFormProps = {
  setAddressEntered: (addressEntered: boolean) => void
  checkServiceability: () => Promise<void>;
  setAddressChanged: React.Dispatch<React.SetStateAction<boolean>>;
  setPhoneNumberEntered: (phoneNumberEntered: boolean) => void;
  serviceInfo: ServiceInfo;
}

const AddressForm: React.FC<AddressFormProps> = ({
  setAddressEntered,
  checkServiceability,
  setAddressChanged,
  setPhoneNumberEntered,
  serviceInfo,
}) => {
  const { 
    address, 
    setAddress, 
    phoneNumber, 
    setPhoneNumber, 
    isServiceable, 
    setIsServiceable,
    isVerified,
    setIsVerified,
    customerName,
    setCustomerName
  } = useAddress();

  const [rememberAddress, setRememberAddress] = useState(false);

  useEffect(() => {
    const savedAddress = localStorage.getItem('savedAddress');
    if (savedAddress) {
      const parsedAddress = JSON.parse(savedAddress);
      setAddress(parsedAddress.address);
      setPhoneNumber(parsedAddress.phoneNumber);
      setCustomerName(parsedAddress.customerName);
      setRememberAddress(true);
      setAddressEntered(true);
      setIsVerified(true);
      checkServiceability();
    }
  }, [setAddress, setPhoneNumber, setCustomerName, setAddressEntered, setIsVerified, checkServiceability]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (address.trim() !== '' && phoneNumber.trim() !== '' && customerName.trim() !== '') {
      setAddressEntered(true);
      setIsServiceable(null);
      await checkServiceability();
      setIsVerified(true);

      if (rememberAddress) {
        localStorage.setItem('savedAddress', JSON.stringify({ address, phoneNumber, customerName }));
      } else {
        localStorage.removeItem('savedAddress');
      }
    }
  }

  const handleAddressChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newAddress = e.target.value;
    setAddress(newAddress);
    setIsServiceable(null);
    setAddressChanged(true);
    setIsVerified(false);
  }

  const handlePhoneNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPhoneNumber(e.target.value)
    setPhoneNumberEntered(e.target.value.trim() !== '')
  }

  const handleCustomerNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {  // Add this function
    setCustomerName(e.target.value);
  }

  const handleRememberAddressChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newRememberAddress = e.target.checked;
    setRememberAddress(newRememberAddress);
    
    if (newRememberAddress) {
      localStorage.setItem('savedAddress', JSON.stringify({ address, phoneNumber, customerName }));
    } else {
      localStorage.removeItem('savedAddress');
    }
  }

  return (
    <Card className={`border-2 ${isVerified ? 'border-gray-300' : 'border-blue-500'} shadow-lg p-4 sm:p-6`}>
      <CardHeader>
        <CardTitle className={`text-xl sm:text-2xl font-bold ${isVerified ? 'text-gray-600' : 'text-blue-600'}`}>Get Started</CardTitle>
        <CardDescription className="text-sm sm:text-base text-gray-700">NightOwl is a delivery-only service. Please enter your name, address, and phone number to get started.</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit}>
          <div className="grid w-full items-center gap-4">
            <div className="flex flex-col space-y-1.5">
              <Label htmlFor="customerDetails">Name, Address, and Phone Number</Label>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-2">
                <Input
                  id="customerName"
                  placeholder="Name"
                  value={customerName}
                  onChange={handleCustomerNameChange}
                  className={`${isVerified ? 'bg-gray-100' : 'bg-blue-50'}`}
                />
                <Input
                  type="tel"
                  placeholder="Phone Number"
                  value={phoneNumber}
                  onChange={handlePhoneNumberChange}
                  className={`${isVerified ? 'bg-gray-100' : 'bg-blue-50'}`}
                />
                <Input
                  id="address"
                  placeholder="Full Address"
                  value={address}
                  onChange={handleAddressChange}
                  className={`sm:col-span-2 ${isVerified ? 'bg-gray-100' : 'bg-blue-50'}`}
                />
              </div>
              <Button 
                type="submit" 
                disabled={isVerified || address.trim() === '' || phoneNumber.trim() === '' || customerName.trim() === ''}
                className={`w-full mt-4 ${isVerified ? (isServiceable ? 'bg-gray-300 text-gray-600' : 'bg-red-500 text-white') : 'bg-blue-500 text-white'}`}
              >
                {isVerified 
                  ? (isServiceable 
                    ? "Address Verified" 
                    : "Not Serviceable")
                  : "Check Details"
                }
              </Button>
            </div>
          </div>
        </form>
        {isVerified && (
          <div className="mt-4 p-4 rounded-md border">
            {isServiceable === true && (
              <div>
                <div className="flex items-center text-green-600">
                  <Check className="mr-2 h-5 w-5" />
                  <span className="font-medium">Great news! We can deliver to you. Start shopping below.</span>
                </div>
                <div className="flex items-center space-x-2 mt-4">
                  <input
                    type="checkbox"
                    id="rememberAddress"
                    checked={rememberAddress}
                    onChange={handleRememberAddressChange}
                    className="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50"
                  />
                  <label
                    htmlFor="rememberAddress"
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                  >
                    Remember my address
                  </label>
                </div>
              </div>
            )}
            {isServiceable === false && (
              <div className="flex items-center text-red-600">
                <X className="mr-2 h-5 w-5" />
                <span className="font-medium">We are sorry but we can not deliver to your address at this time.</span>
              </div>
            )}
            {isServiceable === null && (
              <div className="flex items-center text-yellow-600">
                <span className="font-medium">Checking serviceability...</span>
              </div>
            )}
          </div>
        )}
        <div className="mt-4 p-4 bg-blue-50 rounded-md">
          <h3 className="text-lg font-semibold mb-2">Service Information</h3>
          <ul className="list-disc list-inside text-sm">
            <li>Estimated delivery time: {serviceInfo.deliveryTime}</li>
            <li>Service area: {serviceInfo.serviceArea}</li>
            <li>Minimum order value: ${serviceInfo.minOrderValue.toFixed(2)}</li>
          </ul>
        </div>
      </CardContent>
    </Card>
  )
}

export default AddressForm

================
File: components/Cart.tsx
================
import React, { useState, useMemo, useEffect } from 'react'
import { X, AlertCircle, ShoppingCart, Trash2, CheckCircle, Clock } from 'lucide-react'
import { Button } from "@/components/ui/button"
import { loadStripe } from '@stripe/stripe-js'
import { Elements, CardElement, useStripe, useElements } from '@stripe/react-stripe-js'
import { CartItem } from '@/types/cart'
import { useCart } from '../context/CartContext'
import { storeConfig } from '@/config/config'
import { useAddress } from '../context/AddressContext'; // Add this import
import { useQuery } from '@tanstack/react-query'

interface CartProps {
  isCartOpen: boolean;
  setIsCartOpen: (isOpen: boolean) => void;
  cart: CartItem[];
  updateQuantity: (id: string, increment: boolean) => void;
  removeFromCart: (id: string) => void;
  deliveryCharge: number;
  isAddressValid: boolean;
  getTotalPrice: () => number;
  isStoreOpen: boolean;
}

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!)

function CheckoutForm({ total, onSuccess, isMinOrderMet, isAddressValid, customerInfo, cartItems, removeFromCart, updateQuantity }: { 
  total: number; 
  onSuccess: () => void; 
  isMinOrderMet: boolean; 
  isAddressValid: boolean;
  customerInfo: {
    name: string;
    phone: string;
    address: string;
  };
  cartItems: CartItem[];
  removeFromCart: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
}) {
  const stripe = useStripe()
  const elements = useElements()
  const [error, setError] = useState<string | null>(null)
  const [processing, setProcessing] = useState(false)

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    setProcessing(true)

    if (!stripe || !elements) {
      return
    }

    // Convert total to cents and round to avoid floating point issues
    const amountInCents = Math.round(total * 100)

    const response = await fetch('/api/create-payment-intent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        amount: amountInCents,
        customerInfo: customerInfo,
        cartItems: cartItems
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      if (data.error === 'Inventory changes detected') {
        setError(data.message);
        updateCartWithAvailableQuantities(data.outOfStockItems);
      } else {
        setError(data.error || 'An error occurred');
      }
      setProcessing(false);
      return;
    }

    const { clientSecret, error: backendError } = data;

    if (backendError) {
      setError(backendError.message);
      setProcessing(false);
      return;
    }

    const cardElement = elements.getElement(CardElement);
    if (!cardElement) {
      setError('Card element not found');
      setProcessing(false);
      return;
    }

    const { error, paymentIntent } = await stripe.confirmCardPayment(clientSecret, {
      payment_method: {
        card: cardElement,
      },
    })

    if (error) {
      setError(error.message || 'An error occurred')
    } else if (paymentIntent.status === 'succeeded') {
      onSuccess()
    }

    setProcessing(false)
  }

  const updateCartWithAvailableQuantities = (outOfStockItems: { id: string; availableQuantity: number }[]) => {
    outOfStockItems.forEach(item => {
      if (item.availableQuantity === 0) {
        removeFromCart(item.id);
      } else {
        updateQuantity(item.id, item.availableQuantity);
      }
    });
  }

  return (
    <form onSubmit={handleSubmit}>
      <CardElement />
      {error && <div className="text-red-500 mt-2">{error}</div>}
      <Button 
        className="w-full mt-4" 
        type="submit"
        disabled={!stripe || processing || !isMinOrderMet || !isAddressValid}
      >
        {processing ? 'Processing...' : `Pay $${total.toFixed(2)}`}
      </Button>
    </form>
  )
}

// New component for the invalid address message
const InvalidAddressMessage = () => (
  <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 rounded">
    <div className="flex items-center">
      <AlertCircle className="flex-shrink-0 mr-2" size={20} />
      <div>
        <p className="font-bold">Invalid Address</p>
        <p>
          Your current address is not serviceable. Please update your address to continue.
        </p>
      </div>
    </div>
  </div>
)

// Add this type definition at the top of your file
type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

// Add this type definition at the top of your file
type Product = {
  id: number;
  inventory: number;
  // Add other product properties as needed
};

async function fetchProducts() {
  const response = await fetch('/api/products');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  return response.json();
}

export default function Cart({
  isCartOpen,
  setIsCartOpen,
  deliveryCharge,
  isStoreOpen,
}: CartProps) {
  const { cart, removeFromCart, updateQuantity, clearCart } = useCart();
  
  // Calculate subtotal and total number of items
  const { subtotal, totalItems } = useMemo(() => {
    return cart.reduce((acc, item) => ({
      subtotal: acc.subtotal + item.price * item.quantity,
      totalItems: acc.totalItems + item.quantity
    }), { subtotal: 0, totalItems: 0 });
  }, [cart]);

  const [topUpAmount, setTopUpAmount] = useState(0);

  // Calculate top-up amount whenever the cart or subtotal changes
  useEffect(() => {
    if (subtotal < storeConfig.serviceInfo.minOrderValue) {
      setTopUpAmount(storeConfig.serviceInfo.minOrderValue - subtotal);
    } else {
      setTopUpAmount(0);
    }
  }, [subtotal]);

  // Recalculate total including top-up amount
  const total = subtotal + deliveryCharge + topUpAmount;
  const isMinOrderMet = subtotal + topUpAmount >= storeConfig.serviceInfo.minOrderValue;

  const [paymentSuccess, setPaymentSuccess] = useState(false)
  const [expectedDeliveryTime, setExpectedDeliveryTime] = useState<string | null>(null)

  const { customerName, address, phoneNumber, isServiceable } = useAddress();
  const firstName = customerName.split(' ')[0];

  const { data: products } = useQuery<Product[]>({
    queryKey: ['products'],
    queryFn: fetchProducts
  });

  const handlePaymentSuccess = async () => {
    const expectedDeliveryTime = calculateExpectedDeliveryTime();
    setExpectedDeliveryTime(expectedDeliveryTime);
    setPaymentSuccess(true)
    clearCart() // Clear the cart upon successful payment

    // Generate a random order ID (you might want to replace this with a real order ID generation system)
    const orderId = Math.floor(100000 + Math.random() * 900000);

    // Prepare order information with real customer data
    const orderInfo = {
      orderId: orderId,
      customer: customerName, // Use real customer name
      phone: phoneNumber, // Use real phone number
      address: address, // Use real address
      items: cart.map(item => ({
        name: item.name,
        quantity: item.quantity,
        price: item.price
      })),
      total: subtotal,
      deliveryCharge: deliveryCharge,
      specialInstructions: "" // You might want to add a field for special instructions in your AddressForm if needed
    }

    // Send order information to Slack
    try {
      const response = await fetch('/api/send-slack-notification', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderInfo),
      })

      if (!response.ok) {
        console.error('Failed to send Slack notification')
      }
    } catch (error) {
      console.error('Error sending Slack notification:', error)
    }

    // Here you would typically update order status, send confirmation, etc.
  }

  const handleUpdateQuantity = (id: string, increment: boolean) => {
    if (!isServiceable) return; // Prevent quantity updates if address is not serviceable
    const item = cart.find(item => item.id === id);
    if (item && products) {
      const product = products.find((p: Product) => p.id.toString() === id);
      if (product) {
        const currentQuantity = item.quantity;
        const newQuantity = increment ? currentQuantity + 1 : Math.max(1, currentQuantity - 1);
        
        if (increment && newQuantity > product.inventory) {
          // Don't allow increasing quantity beyond available inventory
          return;
        }
        
        updateQuantity(id, newQuantity);
      }
    } else {
      console.log(`Item with id ${id} not found in cart or products not loaded`);
    }
  };

  const calculateExpectedDeliveryTime = () => {
    const now = new Date();
    const [minTime, maxTime] = storeConfig.serviceInfo.deliveryTime.split('-').map(t => parseInt(t));
    const averageTime = (minTime + maxTime) / 2;
    const deliveryTime = new Date(now.getTime() + averageTime * 60000);
    return deliveryTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
  };

  const [nextOpeningTime, setNextOpeningTime] = useState('')
  const [timeUntilOpen, setTimeUntilOpen] = useState('')

  useEffect(() => {
    if (!isStoreOpen) {
      const updateNextOpeningTime = () => {
        const now = new Date()
        const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase()
        const daysOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
        
        let daysToAdd = 0
        let nextDay = currentDay
        
        while (daysToAdd < 7) {
          const { open } = storeConfig.hours[nextDay as DayOfWeek];
          const [openHour, openMinute] = open.split(':').map(Number)
          
          const nextOpenTime = new Date(now)
          nextOpenTime.setDate(now.getDate() + daysToAdd)
          nextOpenTime.setHours(openHour, openMinute, 0, 0)
          
          if (nextOpenTime > now) {
            setNextOpeningTime(nextOpenTime.toLocaleString('en-US', { 
              weekday: 'long', 
              hour: 'numeric', 
              minute: 'numeric', 
              hour12: true 
            }))
            const timeDiff = nextOpenTime.getTime() - now.getTime()
            const hours = Math.floor(timeDiff / (1000 * 60 * 60))
            const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60))
            setTimeUntilOpen(`${hours}h ${minutes}m`)
            break
          }
          
          daysToAdd++
          nextDay = daysOfWeek[(daysOfWeek.indexOf(nextDay) + 1) % 7]
        }
      }

      updateNextOpeningTime()
      const intervalId = setInterval(updateNextOpeningTime, 60000) // Update every minute
      return () => clearInterval(intervalId)
    }
  }, [isStoreOpen])

  return (
    <>
      {/* Dark overlay */}
      {isCartOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40"
          onClick={() => setIsCartOpen(false)}
        />
      )}
      
      {/* Cart component */}
      <div className={`fixed inset-y-0 right-0 w-full sm:w-[28rem] lg:w-[32rem] bg-white shadow-lg transform ${isCartOpen ? 'translate-x-0' : 'translate-x-full'} transition-transform duration-300 ease-in-out overflow-y-auto z-50`}>
        <div className="p-6 h-full flex flex-col">
          {/* Cart header */}
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold flex items-center">
              <ShoppingCart className="mr-2" size={24} />
              {totalItems > 0 ? `Your Cart (${totalItems} items)` : 'Your Cart'}
            </h2>
            <button onClick={() => setIsCartOpen(false)} className="text-gray-500 hover:text-gray-700">
              <X size={24} />
            </button>
          </div>

          {/* Divider */}
          <div className="border-b border-gray-200 mb-6"></div>

          {paymentSuccess ? (
            <div className="flex-grow flex items-center justify-center">
              <div className="bg-white p-6 rounded-lg shadow-md w-full max-w-md border border-gray-200">
                <div className="flex items-center justify-center mb-6">
                  <CheckCircle className="text-green-500 w-16 h-16" />
                </div>
                <h3 className="font-bold text-2xl mb-4 text-center">Order Received!</h3>
                <div className="space-y-4">
                  <p className="text-center">Thank you for your order, {firstName}.</p>
                  <p className="text-center font-semibold">
                    We expect to deliver to you by:<br />
                    <span className="text-xl">{expectedDeliveryTime}</span>
                  </p>
                  <p className="text-center text-sm text-gray-500 mt-2">
                    We&apos;ll do our best to meet this time, but please note that actual delivery time may vary due to unforeseen circumstances.
                  </p>
                </div>
                <Button 
                  className="mt-8 w-full"
                  onClick={() => {
                    setPaymentSuccess(false)
                    setIsCartOpen(false)
                  }}
                >
                  Close and Continue Shopping
                </Button>
              </div>
            </div>
          ) : cart.length === 0 ? (
            <div className="flex-grow flex items-center justify-center">
              <p className="text-center text-gray-500">Your cart is empty</p>
            </div>
          ) : (
            <>
              <div className="flex-grow overflow-y-auto mb-6">
                {cart.map((item) => (
                  <div key={item.id} className="flex justify-between items-center mb-4 pb-4 border-b">
                    <div>
                      <h3 className="font-semibold">{item.name}</h3>
                      <p className="text-gray-600">${item.price.toFixed(2)} each</p>
                    </div>
                    <div className="flex items-center">
                      <button 
                        onClick={() => handleUpdateQuantity(item.id, false)} 
                        className="px-2 py-1 bg-gray-200 rounded-l"
                        disabled={!isServiceable}
                      >
                        -
                      </button>
                      <span className="px-4 py-1 bg-gray-100">{item.quantity}</span>
                      <button 
                        onClick={() => handleUpdateQuantity(item.id, true)} 
                        className="px-2 py-1 bg-gray-200 rounded-r"
                        disabled={!isServiceable}
                      >
                        +
                      </button>
                      <button 
                        onClick={() => removeFromCart(item.id)} 
                        className="ml-4 text-gray-500 hover:text-red-500 transition-colors duration-200"
                        disabled={!isServiceable}
                      >
                        <Trash2 size={20} />
                      </button>
                    </div>
                  </div>
                ))}
              </div>

              {/* Order summary and payment section */}
              <div className="mt-auto">
                {/* Order summary */}
                <div className="bg-gray-100 p-4 rounded-lg mb-4">
                  <h3 className="font-bold text-lg mb-2">Order Summary</h3>
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <span>Subtotal:</span>
                      <span className="font-semibold">${subtotal.toFixed(2)}</span>
                    </div>
                    {topUpAmount > 0 && (
                      <div className="flex justify-between">
                        <span>Min Order Top-Up:</span>
                        <span className="font-semibold">${topUpAmount.toFixed(2)}</span>
                      </div>
                    )}
                    <div className="flex justify-between">
                      <span>Delivery Charge:</span>
                      <span className="font-semibold">${deliveryCharge.toFixed(2)}</span>
                    </div>
                    <div className="flex justify-between text-lg font-bold border-t pt-2">
                      <span>Total:</span>
                      <span>${total.toFixed(2)}</span>
                    </div>
                  </div>
                </div>

                {/* Invalid address message or Payment section */}
                {!isStoreOpen && cart.length > 0 ? (
                  <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 rounded flex items-start">
                    <AlertCircle className="flex-shrink-0 mr-2 mt-1" size={20} />
                    <div>
                      <p className="font-bold">Store is currently closed</p>
                      <p>We&apos;re sorry, but we are not accepting orders at this time.</p>
                      <div className="flex items-center mt-2 text-gray-600">
                        <Clock className="mr-2 h-5 w-5" />
                        <span>Open again in: {timeUntilOpen}</span>
                      </div>
                      <p className="mt-1 text-sm text-gray-600">
                        Next opening time: {nextOpeningTime}
                      </p>
                    </div>
                  </div>
                ) : (
                  <>
                    {!isServiceable ? (
                      <InvalidAddressMessage />
                    ) : (
                      <div className="bg-white p-4 rounded-lg border">
                        <h3 className="font-bold text-lg mb-4">Payment</h3>
                        {topUpAmount > 0 && (
                          <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 rounded">
                            <p>A top-up amount of ${topUpAmount.toFixed(2)} has been added to meet the minimum order value.</p>
                          </div>
                        )}
                        <Elements stripe={stripePromise}>
                          <CheckoutForm 
                            total={total} 
                            onSuccess={handlePaymentSuccess} 
                            isMinOrderMet={isMinOrderMet}
                            isAddressValid={isServiceable}
                            customerInfo={{
                              name: customerName,
                              phone: phoneNumber,
                              address: address,
                            }}
                            cartItems={cart}
                            removeFromCart={removeFromCart}
                            updateQuantity={updateQuantity}
                          />
                        </Elements>
                      </div>
                    )}
                  </>
                )}
              </div>
            </>
          )}
        </div>
      </div>
    </>
  )
}

================
File: components/CartButton.tsx
================
import React from 'react'
import { Button } from "@/components/ui/button"
import { ShoppingCart } from 'lucide-react'

interface CartButtonProps {
  isCartOpen: boolean;
  setIsCartOpen: React.Dispatch<React.SetStateAction<boolean>>;
  itemCount: number;  // Change this from totalItems to itemCount
}

const CartButton: React.FC<CartButtonProps> = React.memo(({ isCartOpen, setIsCartOpen, itemCount }) => {
  
  return (
    <Button onClick={() => setIsCartOpen(!isCartOpen)} variant="outline" className="relative">
      <ShoppingCart className="h-4 w-4 mr-2" />
      Cart
      {itemCount > 0 && (
        <span className="absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
          {itemCount}
        </span>
      )}
    </Button>
  )
});

CartButton.displayName = 'CartButton';

export default CartButton;

================
File: components/ClosedStoreNotice.tsx
================
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { Clock } from 'lucide-react'
import { useEffect, useState } from 'react'
import { storeConfig } from '@/config/config'

const ClosedStoreNotice: React.FC = () => {
  const [nextOpeningDay, setNextOpeningDay] = useState('')
  const [nextOpeningTimeFormatted, setNextOpeningTimeFormatted] = useState('')
  const [timeUntilOpen, setTimeUntilOpen] = useState('')

  const formatTime = (time: string): string => {
    const [hours, minutes] = time.split(':').map(Number);
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const formattedHours = hours % 12 || 12;
    return `${formattedHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
  };

  const calculateTimeUntilOpen = (openingTime: Date) => {
    const diff = openingTime.getTime() - new Date().getTime();
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
    return `${hours}h ${minutes}m ${seconds}s`;
  };

  useEffect(() => {
    const updateStoreStatus = () => {
      const currentTime = new Date();
      const currentDay = currentTime.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
      const daysOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      
      let daysToAdd = 0;
      let nextDay = currentDay;
      let foundNextOpenDay = false;
      let nextOpeningTime: Date | null = null;

      while (!foundNextOpenDay && daysToAdd < 7) {
        const { open, close } = storeConfig.hours[nextDay as keyof typeof storeConfig.hours];

        const [openHour, openMinute] = open.split(':').map(Number);
        const [closeHour, closeMinute] = close.split(':').map(Number);
        
        const openingTime = new Date(currentTime);
        openingTime.setDate(currentTime.getDate() + daysToAdd);
        openingTime.setHours(openHour, openMinute, 0, 0);

        const closingTime = new Date(currentTime);
        closingTime.setDate(currentTime.getDate() + daysToAdd);
        closingTime.setHours(closeHour, closeMinute, 0, 0);

        if (closeHour < openHour) {
          closingTime.setDate(closingTime.getDate() + 1);
        }

        if (currentTime >= openingTime && currentTime < closingTime) {
          // Store is currently open
          foundNextOpenDay = true;
          setNextOpeningDay('now');
          setNextOpeningTimeFormatted('We are currently open');
        } else if (currentTime < openingTime) {
          // Store will open later today or in the future
          foundNextOpenDay = true;
          setNextOpeningDay(daysToAdd === 0 ? 'today' : daysToAdd === 1 ? 'tomorrow' : nextDay);
          setNextOpeningTimeFormatted(formatTime(open));
          nextOpeningTime = openingTime;
        } else {
          // Move to the next day
          daysToAdd++;
          nextDay = daysOfWeek[(daysOfWeek.indexOf(nextDay) + 1) % 7];
        }
      }

      if (nextOpeningTime) {
        setTimeUntilOpen(calculateTimeUntilOpen(nextOpeningTime));
      }
    };

    updateStoreStatus();
    const intervalId = setInterval(updateStoreStatus, 1000);

    return () => clearInterval(intervalId);
  }, []);

  return (
    <Card className="border-2 border-yellow-500 shadow-lg p-4 sm:p-6">
      <CardHeader>
        <CardTitle className="text-xl sm:text-2xl font-bold text-yellow-600">
          {nextOpeningDay === 'now' ? 'Store is Open' : 'Store is Currently Closed'}
        </CardTitle>
        <CardDescription className="text-sm sm:text-base text-gray-700">
          {nextOpeningDay === 'now' 
            ? "We're accepting orders now!"
            : "We're sorry, but we're not accepting orders at this time."}
        </CardDescription>
      </CardHeader>
      <CardContent>
        {nextOpeningDay !== 'now' && (
          <>
            <div className="flex items-center text-yellow-600 mb-4">
              <Clock className="mr-2 h-5 w-5" />
              <span className="font-medium">Open again in: {timeUntilOpen}</span>
            </div>
            <p className="text-sm text-gray-600">
              We will open at <strong>{nextOpeningTimeFormatted}</strong> {nextOpeningDay}.
            </p>
            <p className="mt-4 text-sm text-gray-600">
              Please check back during our operating hours to place an order. We appreciate your patience!
            </p>
          </>
        )}
      </CardContent>
    </Card>
  )
}

export default ClosedStoreNotice

================
File: components/Footer.tsx
================
import Link from 'next/link'
import { siteInfo } from '@/config/config'
import { Facebook, Twitter, Instagram } from 'lucide-react'

export default function Footer() {
  return (
    <footer className="bg-gray-100 text-gray-800 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 justify-items-center md:justify-items-stretch">
          <div className="text-center md:text-left">
            <h3 className="text-lg font-semibold mb-4">{siteInfo.name}</h3>
            <p className="text-sm">{siteInfo.shortDescription}</p>
          </div>
          <div className="text-center">
            <h3 className="text-lg font-semibold mb-4">Contact Us</h3>
            <p className="text-sm">Email: {siteInfo.supportEmail}</p>
            <p className="text-sm">Phone: {siteInfo.supportPhone}</p>
          </div>
          <div className="text-center md:text-right">
            <h3 className="text-lg font-semibold mb-4">Follow Us</h3>
            <div className="flex justify-center md:justify-end space-x-4">
              <Link href={siteInfo.socialMedia.facebook} className="text-gray-600 hover:text-blue-600">
                <Facebook size={24} />
              </Link>
              <Link href={siteInfo.socialMedia.twitter} className="text-gray-600 hover:text-blue-400">
                <Twitter size={24} />
              </Link>
              <Link href={siteInfo.socialMedia.instagram} className="text-gray-600 hover:text-pink-600">
                <Instagram size={24} />
              </Link>
            </div>
          </div>
        </div>
        <div className="mt-8 border-t border-gray-200 pt-8 text-center text-sm text-gray-600">
          © {new Date().getFullYear()} {siteInfo.name}. All rights reserved.
        </div>
      </div>
    </footer>
  )
}

================
File: components/ProductGrid.tsx
================
'use client';

import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { useAddress } from '../context/AddressContext'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Plus, Minus } from 'lucide-react'
import Image from 'next/image'
import { useCart } from '../context/CartContext'
import { LOW_STOCK_THRESHOLD } from '@/config/config'
import { SHOW_OUT_OF_STOCK_ITEMS } from '@/config/config'

async function fetchProducts() {
  const response = await fetch('/api/products');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data = await response.json();
  //console.log('Fetched products:', data);
  return data;
}

interface Product {
  id: number;
  name: string;
  category_id: string;
  price: number;
  image: string | null;
  inventory: number;
  visible: boolean;
}

interface ProductGridProps {
  isStoreOpen: boolean;
}

function ProductGrid({ isStoreOpen }: ProductGridProps) {
  const { data: products, isLoading, error } = useQuery({
    queryKey: ['products'],
    queryFn: fetchProducts
  });

  //console.log('Products from useQuery:', products);
  //console.log('isLoading:', isLoading);
  //console.log('error:', error);

  const { cart, addToCart, removeFromCart, updateQuantity } = useCart();
  const { isServiceable, isVerified } = useAddress();

  const getItemQuantity = (id: number) => {
    const item = cart.find(item => item.id === id.toString());
    return item ? item.quantity : 0;
  };

  const handleUpdateQuantity = (product: Product, increment: boolean) => {
    const currentQuantity = getItemQuantity(product.id);
    const newQuantity = increment ? currentQuantity + 1 : Math.max(0, currentQuantity - 1);
    
    if (increment && newQuantity > product.inventory) {
      return;
    }
    
    if (newQuantity === 0) {
      removeFromCart(product.id.toString());
    } else {
      updateQuantity(product.id.toString(), newQuantity);
    }
  };

  const isLowStock = (inventory: number) => inventory <= LOW_STOCK_THRESHOLD && inventory > 0;
  const isOutOfStock = (inventory: number) => inventory === 0;

  if (isLoading) return <div>Loading products...</div>;
  if (error) return <div>Error loading products</div>;
  if (!products || products.length === 0) return <div>No products available</div>;

  const validProducts = products.filter((product: Product) => 
    product.category_id && 
    product.category_id.trim() !== '' && 
    product.visible &&
    (SHOW_OUT_OF_STOCK_ITEMS || product.inventory > 0)
  );

  //console.log('validProducts:', validProducts);

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {validProducts.map((product: Product) => (
        <Card key={product.id} className={isOutOfStock(product.inventory) ? "opacity-60" : ""}>
          <CardHeader>
            <div className="flex justify-between items-start">
              <CardTitle>{product.name}</CardTitle>
              <span className="px-2 py-1 bg-gray-200 text-gray-800 text-xs font-semibold rounded-full">
                {product.category_id}
              </span>
            </div>
          </CardHeader>
          <CardContent className="p-4 flex flex-col h-[calc(100%-130px)]">
            <div className="relative w-full aspect-square mb-2">
              <Image 
                src={product.image ? `/product-images/${product.image}` : "/images/placeholder.png"}
                alt={product.name} 
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                className="rounded-md" 
                style={{ objectFit: 'cover' }}
              />
            </div>
            <div className="flex-grow">
              <p>Price: ${product.price.toFixed(2)}</p>
              {isLowStock(product.inventory) && (
                <p className="text-yellow-600 text-sm mt-1">Low stock</p>
              )}
              {isOutOfStock(product.inventory) && (
                <p className="text-red-600 text-sm mt-1 font-semibold">Out of stock</p>
              )}
            </div>
          </CardContent>
          <CardFooter>
            {isStoreOpen && isVerified && isServiceable ? (
              <div className="w-full flex justify-end">
                {getItemQuantity(product.id) > 0 ? (
                  <div className="flex items-center">
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleUpdateQuantity(product, false)}
                      disabled={isOutOfStock(product.inventory)}
                    >
                      <Minus className="h-4 w-4" />
                    </Button>
                    <span className="mx-2">{getItemQuantity(product.id)}</span>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleUpdateQuantity(product, true)}
                      disabled={getItemQuantity(product.id) >= product.inventory || isOutOfStock(product.inventory)}
                    >
                      <Plus className="h-4 w-4" />
                    </Button>
                  </div>
                ) : (
                  <Button 
                    onClick={() => {
                      addToCart({ id: product.id.toString(), name: product.name, price: product.price, quantity: 1 });
                    }}
                    disabled={isOutOfStock(product.inventory)}
                  >
                    {isOutOfStock(product.inventory) ? 'Out of Stock' : 'Add to Cart'}
                  </Button>
                )}
              </div>
            ) : null}
          </CardFooter>
        </Card>
      ))}
    </div>
  )
}

export default ProductGrid;

================
File: components/TopBar.tsx
================
'use client'

import { useState, useEffect } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { Button } from "@/components/ui/button"
import CartButton from './CartButton'
import { storeConfig } from '../config/config'
import { useCart } from '../context/CartContext'

const formatHour = (time: string) => {
  const [hours, minutes] = time.split(':').map(Number);
  const period = hours >= 12 ? 'PM' : 'AM';
  const displayHours = hours % 12 || 12;
  return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
};

const formatHours = (hours: { open: string; close: string } | undefined) => {
  if (!hours) return 'Closed today';
  return `${formatHour(hours.open)} - ${formatHour(hours.close)}`;
};

interface TopBarProps {
  currentPage: 'home' | 'about';
  isCartOpen: boolean;
  setIsCartOpen: React.Dispatch<React.SetStateAction<boolean>>;
}

export default function TopBar({ currentPage, isCartOpen, setIsCartOpen }: TopBarProps) {
  const { cart } = useCart()
  const [storeStatus, setStoreStatus] = useState('CLOSED')
  const [todayHours, setTodayHours] = useState<{ open: string; close: string } | undefined>(undefined)

  const getTotalItems = () => {
    return cart.reduce((total, item) => total + item.quantity, 0);
  }

  useEffect(() => {
    const checkStoreStatus = () => {
      const now = new Date()
      const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase() as keyof typeof storeConfig.hours
      const currentHour = now.getHours()
      const currentMinute = now.getMinutes()
      const hours = storeConfig.hours[currentDay]
      
      setTodayHours(hours)
      
      if (!hours) {
        setStoreStatus('CLOSED')
        return
      }

      const [openHour, openMinute] = hours.open.split(':').map(Number)
      const [closeHour, closeMinute] = hours.close.split(':').map(Number)
      
      const currentTime = currentHour * 60 + currentMinute
      const openTime = openHour * 60 + openMinute
      let closeTime = closeHour * 60 + closeMinute
      
      // Handle cases where closing time is past midnight
      if (closeTime <= openTime) {
        closeTime += 24 * 60
      }

      if (currentTime >= openTime && currentTime < closeTime) {
        setStoreStatus('OPEN')
      } else if (currentTime < openTime) {
        if (openTime - currentTime <= 30) {
          setStoreStatus('OPENING SOON')
        } else {
          setStoreStatus('OPENING LATER TODAY')
        }
      } else {
        setStoreStatus('CLOSED')
      }
    }

    checkStoreStatus() // Check immediately on mount
    
    // Update every second
    const timer = setInterval(checkStoreStatus, 1000)

    return () => clearInterval(timer)
  }, [])

  return (
    <div className="fixed top-0 left-0 right-0 bg-white shadow-md z-50">
      <div className="max-w-7xl mx-auto px-4 py-2">
        <div className="flex justify-between items-center">
          <div className="flex items-center w-1/3">
            <Image src="/NightOwl.png" alt="NightOwl Logo" width={30} height={30} />
            <h1 className="text-xl font-bold ml-2">NightOwl</h1>
          </div>
          <div className="text-sm text-gray-600 w-1/3 text-center">
            <p className={`font-bold ${
              storeStatus === 'OPEN' ? 'text-green-600' : 
              storeStatus === 'OPENING LATER TODAY' ? 'text-yellow-600' :
              storeStatus === 'OPENING SOON' ? 'text-yellow-600' : 'text-red-600'
            }`}>
              {storeStatus}
            </p>
            <p>Hours: {formatHours(todayHours)}</p>
          </div>
          <div className="flex items-center space-x-4 w-1/3 justify-end">
            {currentPage === 'home' ? (
              <Link href="/about">
                <Button variant="outline" size="sm">
                  Learn More
                </Button>
              </Link>
            ) : (
              <Link href="/">
                <Button variant="outline" size="sm">
                  Back to Home
                </Button>
              </Link>
            )}
            <CartButton 
              isCartOpen={isCartOpen} 
              setIsCartOpen={setIsCartOpen} 
              itemCount={getTotalItems()}
            />
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/home-page.tsx
================
'use client'

import { useState, useEffect, useCallback, useMemo } from 'react'
import { Search, X, Loader2 } from 'lucide-react'
import { Button } from "@/components/ui/button"
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Input } from "@/components/ui/input"
import AddressForm from './AddressForm'
import ProductGrid from './ProductGrid'
import Cart from './Cart'
import { storeConfig, Product, siteInfo } from '../config/config'
import Link from 'next/link'
import { useAddress } from '../context/AddressContext';
import { useCart } from '../context/CartContext'; // Make sure this import is present
import ClosedStoreNotice from './ClosedStoreNotice'
import TopBar from './TopBar'

export function HomePage() {
  const [isStoreOpen, setIsStoreOpen] = useState(false)
  // Remove this line:
  // const [timeUntilOpen, setTimeUntilOpen] = useState('')
  const [selectedCategory, setSelectedCategory] = useState('all')
  const [isCartOpen, setIsCartOpen] = useState(false)
  const [addressEntered, setAddressEntered] = useState(false)
  const [addressChanged, setAddressChanged] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [phoneNumberEntered, setPhoneNumberEntered] = useState(false)
  const [products, setProducts] = useState<Product[]>([])
  const { isServiceable, setIsServiceable } = useAddress();
  const { cart: cartFromContext, updateCart } = useCart(); // Get updateCart function
  const [isLoading, setIsLoading] = useState(true) // Add this state
  const [currentDay, setCurrentDay] = useState<keyof typeof storeConfig.hours>('monday')

  const checkServiceability = useCallback(async () => {
    setIsServiceable(null);

    try {
      await new Promise(resolve => setTimeout(resolve, 1500));
      const isWithinServiceArea = Math.random() < 0.7;
      setIsServiceable(isWithinServiceArea);
    } catch (error) {
      setIsServiceable(false);
    }
  }, [setIsServiceable]);

  useEffect(() => {
    const checkStoreStatus = () => {
      const now = new Date()
      setCurrentDay(now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase() as keyof typeof storeConfig.hours)
      const currentHour = now.getHours()
      const currentMinute = now.getMinutes()
      const { open, close } = storeConfig.hours[currentDay]
      
      const [openHour, openMinute] = open.split(':').map(Number)
      const [closeHour, closeMinute] = close.split(':').map(Number)
      
      const isOpen = (openHour < closeHour || (openHour === closeHour && openMinute < closeMinute)) 
        ? (currentHour > openHour || (currentHour === openHour && currentMinute >= openMinute)) &&
          (currentHour < closeHour || (currentHour === closeHour && currentMinute < closeMinute))
        : (currentHour > openHour || (currentHour === openHour && currentMinute >= openMinute)) ||
          (currentHour < closeHour || (currentHour === closeHour && currentMinute < closeMinute))
      
      setIsStoreOpen(isOpen)

      if (!isOpen) {
        const openingTime = new Date(now)
        openingTime.setHours(openHour, openMinute, 0, 0)
        if (currentHour > closeHour || (currentHour === closeHour && currentMinute >= closeMinute)) {
          openingTime.setDate(openingTime.getDate() + 1)
        }
      }

      setIsLoading(false)
    }

    checkStoreStatus() // Check immediately on mount
    const timer = setInterval(checkStoreStatus, 1000) // Update every second

    return () => clearInterval(timer)
  }, [currentDay])

  const removeFromCart = (id: string) => {
    updateCart(cartFromContext.filter(item => item.id !== id));
  }

  const updateQuantity = (id: string, newQuantity: number) => {
    if (newQuantity < 1) {
      removeFromCart(id);
    } else {
      updateCart(cartFromContext.map(item =>
        item.id === id ? { ...item, quantity: newQuantity } : item
      ));
    }
  }

  const getItemQuantity = (id: string) => {
    const item = cartFromContext.find(item => item.id === id);
    return item ? item.quantity : 0;
  }

  const getTotalPrice = () => {
    return cartFromContext.reduce((total, item) => total + item.price * item.quantity, 0);
  }

  const filteredProducts = products
    .filter(product => 
      (selectedCategory === 'all' || product.category === selectedCategory) &&
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    )

  // New: Get unique categories from filtered products
  const availableCategories = useMemo(() => {
    const categorySet = new Set(filteredProducts.map(product => product.category));
    return ['all', ...Array.from(categorySet)];
  }, [filteredProducts]);

  const isAddressValid = addressEntered && (isServiceable ?? false) && !addressChanged && phoneNumberEntered

  const clearSearch = () => {
    setSearchTerm('')
    setSelectedCategory('all')
  }

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const response = await fetch('/api/products')
        if (!response.ok) {
          throw new Error('Failed to fetch products')
        }
        const data = await response.json()
        setProducts(data)
      } catch (error) {
        console.error('Error fetching products:', error)
      }
    }

    fetchProducts()
  }, [])

  return (
    <div className="min-h-screen bg-gray-100">
      <TopBar 
        currentPage="home" 
        isCartOpen={isCartOpen} 
        setIsCartOpen={setIsCartOpen}
      />

      {/* Main content */}
      <div className="pt-20 p-8">
        <div className="max-w-7xl mx-auto bg-white rounded-lg shadow-lg p-8">
          {/* Welcome section */}
          <div className="mb-8 text-center">
            <h2 className="text-3xl font-bold mb-4">Welcome to NightOwl</h2>
            <div className="max-w-2xl mx-auto">
              <p className="text-gray-600 mb-6">
                {siteInfo.longDescription}
              </p>
              <Link href="/about">
                <Button variant="outline">
                  Learn More
                </Button>
              </Link>
            </div>
          </div>

          {isLoading ? (
            <div className="flex justify-center items-center h-32">
              <Loader2 className="w-8 h-8 animate-spin" />
            </div>
          ) : isStoreOpen ? (
            <AddressForm
              setAddressEntered={setAddressEntered}
              checkServiceability={checkServiceability}
              setAddressChanged={setAddressChanged}
              setPhoneNumberEntered={setPhoneNumberEntered}
              serviceInfo={storeConfig.serviceInfo}
            />
          ) : (
            <ClosedStoreNotice />
          )}

          <div className="relative mt-12 mb-12">
            <h2 className="text-xl font-semibold mb-4 text-center">Products</h2>
            
            <div className="mb-6">
              <Tabs value={selectedCategory} onValueChange={setSelectedCategory} className="w-full">
                <TabsList className="bg-gray-100 p-1 rounded-lg h-10 flex items-center">
                  {availableCategories.map(category => (
                    <TabsTrigger 
                      key={category} 
                      value={category}
                      className="px-3 py-1 text-sm font-medium transition-colors
                                 data-[state=active]:bg-white data-[state=active]:text-blue-600
                                 data-[state=active]:shadow-sm hover:bg-gray-200"
                    >
                      {category === 'all' ? 'All' : category}
                    </TabsTrigger>
                  ))}
                  <div className="relative ml-auto">
                    <Input
                      type="text"
                      placeholder="Search products..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="pl-8 pr-8 py-1 w-48 h-8 text-sm bg-white"
                    />
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-400" size={16} />
                    {searchTerm && (
                      <Button 
                        onClick={clearSearch}
                        variant="ghost" 
                        className="absolute right-1 top-1/2 transform -translate-y-1/2 p-1 h-6 w-6"
                        aria-label="Clear search"
                      >
                        <X size={12} />
                      </Button>
                    )}
                  </div>
                </TabsList>
              </Tabs>
            </div>

            <div>
              {availableCategories.map(category => (
                <div key={category} className={selectedCategory === category ? '' : 'hidden'}>
                  <ProductGrid
                    isStoreOpen={isStoreOpen}
                  />
                </div>
              ))}
            </div>

            <Cart
              isCartOpen={isCartOpen}
              setIsCartOpen={setIsCartOpen}
              cart={cartFromContext}
              isAddressValid={isAddressValid}
              updateQuantity={(id: string, increment: boolean) => 
                updateQuantity(id, getItemQuantity(id) + (increment ? 1 : -1))
              }
              removeFromCart={removeFromCart}
              getTotalPrice={getTotalPrice}
              deliveryCharge={storeConfig.serviceInfo.deliveryCharge}
              isStoreOpen={isStoreOpen} // Add this line
            />
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: config/config.ts
================
export const LOW_STOCK_THRESHOLD = 10;
export const SHOW_OUT_OF_STOCK_ITEMS = true;

export const storeConfig = {
  serviceInfo: {
    deliveryTime: '30-45 minutes (usually quicker)',
    serviceArea: [
      { lat: -43.79766940765112, lng: 172.96398227508365 },
      { lat: -43.817437006348506, lng: 172.94562088651645 },
      { lat: -43.82053879407215, lng: 172.96333877661004 },
      { lat: -43.81464260126724, lng: 172.98003006050743 },
      { lat: -43.81050846182929, lng: 172.98443674119318 },
      { lat: -43.803337709593436, lng: 172.98200671966424 },
      { lat: -43.79742160076273, lng: 172.97797267730726 },
      { lat: -43.79485054364922, lng: 172.9650980740346 },
      { lat: -43.79766940765112, lng: 172.96398227508365 }
    ],
    minOrderValue: 10,
    deliveryCharge: 10
  },
  hours: {
    monday: { open: '08:00', close: '23:00' },
    tuesday: { open: '08:00', close: '23:00' },
    wednesday: { open: '08:00', close: '23:00' },
    thursday: { open: '16:00', close: '21:40' },
    friday: { open: '21:50', close: '00:00' }, // Open until midnight
    saturday: { open: '05:46', close: '20:14' }, // Open until midnight
    sunday: { open: '09:00', close: '22:00' },
  },
};

// Add this new configuration object
export const siteInfo = {
  name: 'NightOwl',
  shortDescription: 'NightOwl is a delivery only service.',
  longDescription: 'NightOwl is your convenient delivery service, offering groceries, household essentials, and more whenever you need them. With quick and reliable deliveries, we are here to make sure you have what you need, when you need it.',
  supportEmail: 'support@nightowl.com',
  supportPhone: '(0800) 123-4567',
  socialMedia: {
    facebook: 'https://facebook.com/nightowl',
    twitter: 'https://twitter.com/nightowl',
    instagram: 'https://instagram.com/nightowl',
  },
};

export const categories = [
  { id: 'all', name: 'All Items' },
  { id: 'health', name: 'Health & Wellness' },
  { id: 'food', name: 'Food & Beverages' },
  { id: 'household', name: 'Household Essentials' },
  { id: 'personal', name: 'Personal Care' },
  { id: 'pet', name: 'Pet Supplies' },
  { id: 'tech', name: 'Tech Accessories' },
  { id: 'tobacco', name: 'Tobacco & Alcohol' },
  { id: 'seasonal', name: 'Seasonal Items' },
  { id: 'convenience', name: 'Convenience Items' }
];

export interface Product {
  id: number;
  name: string;
  category: string;
  price: number;
  image: string | null;
  inventory: number;
  visible: boolean;
}

================
File: context/AddressContext.tsx
================
"use client";

import React, { createContext, useContext, useState, ReactNode } from 'react';

interface AddressContextType {
  address: string;
  setAddress: (address: string) => void;
  phoneNumber: string;
  setPhoneNumber: (phoneNumber: string) => void;
  isServiceable: boolean | null;
  setIsServiceable: (isServiceable: boolean | null) => void;
  isVerified: boolean;
  setIsVerified: (isVerified: boolean) => void;
  customerName: string;
  setCustomerName: (customerName: string) => void;
}

const AddressContext = createContext<AddressContextType | undefined>(undefined);

export const AddressProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [address, setAddress] = useState('');
  const [phoneNumber, setPhoneNumber] = useState('');
  const [isServiceable, setIsServiceable] = useState<boolean | null>(null);
  const [isVerified, setIsVerified] = useState(false);
  const [customerName, setCustomerName] = useState('');

  return (
    <AddressContext.Provider value={{
      address,
      setAddress,
      phoneNumber,
      setPhoneNumber,
      isServiceable,
      setIsServiceable,
      isVerified,
      setIsVerified,
      customerName,
      setCustomerName
    }}>
      {children}
    </AddressContext.Provider>
  );
};

export const useAddress = () => {
  const context = useContext(AddressContext);
  if (context === undefined) {
    throw new Error('useAddress must be used within an AddressProvider');
  }
  return context;
};

================
File: context/CartContext.tsx
================
'use client';

import React, { createContext, useState, useEffect, useContext } from 'react';

type CartItem = {
  id: string;
  name: string;
  price: number;
  quantity: number;
};

export type CartContextType = {
  cart: CartItem[];
  updateCart: (newCart: CartItem[]) => void; // Add this line
  addToCart: (item: CartItem) => void;
  removeFromCart: (id: string) => void;
  clearCart: () => void;
  updateQuantity: (id: string, newQuantity: number) => void;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: React.ReactNode }) {
  const [cart, setCart] = useState<CartItem[]>([]);

  useEffect(() => {
    // Load cart from localStorage on initial render
    const savedCart = localStorage.getItem('cart');
    if (savedCart) {
      setCart(JSON.parse(savedCart));
    }
  }, []);

  useEffect(() => {
    // Save cart to localStorage whenever it changes
    localStorage.setItem('cart', JSON.stringify(cart));
  }, [cart]);

  const addToCart = (item: CartItem) => {
    setCart(prevCart => {
      const existingItem = prevCart.find(cartItem => cartItem.id === item.id);
      if (existingItem) {
        return prevCart.map(cartItem =>
          cartItem.id === item.id
            ? { ...cartItem, quantity: cartItem.quantity + 1 }
            : cartItem
        );
      }
      return [...prevCart, { ...item, quantity: 1 }];
    });
  };

  const removeFromCart = (id: string) => {
    setCart(prevCart => prevCart.filter(item => item.id !== id));
  };

  const clearCart = () => {
    setCart([]);
  };

  const updateQuantity = (id: string, newQuantity: number) => {
    setCart(currentCart =>
      currentCart.map(item =>
        item.id === id ? { ...item, quantity: newQuantity } : item
      )
    );
  };

  const updateCart = (newCart: CartItem[]) => {
    setCart(newCart);
  };

  return (
    <CartContext.Provider value={{ cart, updateCart, addToCart, removeFromCart, clearCart, updateQuantity }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
}

================
File: hooks/useScrollPosition.tsx
================
import { useState, useEffect } from 'react'

export function useScrollPosition() {
  const [scrollPosition, setScrollPosition] = useState(0)

  useEffect(() => {
    const updatePosition = () => {
      setScrollPosition(window.pageYOffset)
    }
    window.addEventListener('scroll', updatePosition)
    updatePosition()
    return () => window.removeEventListener('scroll', updatePosition)
  }, [])

  return scrollPosition
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

================
File: package.json
================
{
  "name": "nightowl",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@icons-pack/react-simple-icons": "^10.0.0",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@react-google-maps/api": "^2.19.3",
    "@slack/web-api": "^7.5.0",
    "@stripe/react-stripe-js": "^2.8.0",
    "@stripe/stripe-js": "^4.4.0",
    "@supabase/supabase-js": "^2.45.4",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.441.0",
    "next": "14.2.11",
    "react": "^18",
    "react-dom": "^18",
    "stripe": "^16.11.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.11",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: types/cart.ts
================
export interface CartItem {
  id: string; // Change this to string
  name: string;
  price: number;
  quantity: number;
}

================
File: utils/mapUtils.ts
================
import { LoadScriptNext } from '@react-google-maps/api';

const libraries = ['geometry', 'places'];

export const MapApiWrapper = ({ children }: { children: React.ReactNode }) => (
  <LoadScriptNext
    googleMapsApiKey={process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!}
    libraries={libraries as any}
  >
    {children}
  </LoadScriptNext>
);

export function isPointInPolygon(point: google.maps.LatLngLiteral, polygon: google.maps.LatLngLiteral[]) {
  const googlePolygon = new google.maps.Polygon({ paths: polygon });
  return google.maps.geometry.poly.containsLocation(
    new google.maps.LatLng(point.lat, point.lng),
    googlePolygon
  );
}
